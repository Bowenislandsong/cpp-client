/**
 * Autogenerated by Thrift Compiler (0.10.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "sampling_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace uber { namespace jaeger { namespace thrift { namespace sampling_manager {

int _kSamplingStrategyTypeValues[] = {
  SamplingStrategyType::PROBABILISTIC,
  SamplingStrategyType::RATE_LIMITING
};
const char* _kSamplingStrategyTypeNames[] = {
  "PROBABILISTIC",
  "RATE_LIMITING"
};
const std::map<int, const char*> _SamplingStrategyType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kSamplingStrategyTypeValues, _kSamplingStrategyTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));


ProbabilisticSamplingStrategy::~ProbabilisticSamplingStrategy() throw() {
}


void ProbabilisticSamplingStrategy::__set_samplingRate(const double val) {
  this->samplingRate = val;
}

uint32_t ProbabilisticSamplingStrategy::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_samplingRate = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->samplingRate);
          isset_samplingRate = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_samplingRate)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ProbabilisticSamplingStrategy::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ProbabilisticSamplingStrategy");

  xfer += oprot->writeFieldBegin("samplingRate", ::apache::thrift::protocol::T_DOUBLE, 1);
  xfer += oprot->writeDouble(this->samplingRate);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ProbabilisticSamplingStrategy &a, ProbabilisticSamplingStrategy &b) {
  using ::std::swap;
  swap(a.samplingRate, b.samplingRate);
}

ProbabilisticSamplingStrategy::ProbabilisticSamplingStrategy(const ProbabilisticSamplingStrategy& other0) {
  samplingRate = other0.samplingRate;
}
ProbabilisticSamplingStrategy::ProbabilisticSamplingStrategy( ProbabilisticSamplingStrategy&& other1) {
  samplingRate = std::move(other1.samplingRate);
}
ProbabilisticSamplingStrategy& ProbabilisticSamplingStrategy::operator=(const ProbabilisticSamplingStrategy& other2) {
  samplingRate = other2.samplingRate;
  return *this;
}
ProbabilisticSamplingStrategy& ProbabilisticSamplingStrategy::operator=(ProbabilisticSamplingStrategy&& other3) {
  samplingRate = std::move(other3.samplingRate);
  return *this;
}
void ProbabilisticSamplingStrategy::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ProbabilisticSamplingStrategy(";
  out << "samplingRate=" << to_string(samplingRate);
  out << ")";
}


RateLimitingSamplingStrategy::~RateLimitingSamplingStrategy() throw() {
}


void RateLimitingSamplingStrategy::__set_maxTracesPerSecond(const int16_t val) {
  this->maxTracesPerSecond = val;
}

uint32_t RateLimitingSamplingStrategy::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_maxTracesPerSecond = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->maxTracesPerSecond);
          isset_maxTracesPerSecond = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_maxTracesPerSecond)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t RateLimitingSamplingStrategy::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("RateLimitingSamplingStrategy");

  xfer += oprot->writeFieldBegin("maxTracesPerSecond", ::apache::thrift::protocol::T_I16, 1);
  xfer += oprot->writeI16(this->maxTracesPerSecond);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(RateLimitingSamplingStrategy &a, RateLimitingSamplingStrategy &b) {
  using ::std::swap;
  swap(a.maxTracesPerSecond, b.maxTracesPerSecond);
}

RateLimitingSamplingStrategy::RateLimitingSamplingStrategy(const RateLimitingSamplingStrategy& other4) {
  maxTracesPerSecond = other4.maxTracesPerSecond;
}
RateLimitingSamplingStrategy::RateLimitingSamplingStrategy( RateLimitingSamplingStrategy&& other5) {
  maxTracesPerSecond = std::move(other5.maxTracesPerSecond);
}
RateLimitingSamplingStrategy& RateLimitingSamplingStrategy::operator=(const RateLimitingSamplingStrategy& other6) {
  maxTracesPerSecond = other6.maxTracesPerSecond;
  return *this;
}
RateLimitingSamplingStrategy& RateLimitingSamplingStrategy::operator=(RateLimitingSamplingStrategy&& other7) {
  maxTracesPerSecond = std::move(other7.maxTracesPerSecond);
  return *this;
}
void RateLimitingSamplingStrategy::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "RateLimitingSamplingStrategy(";
  out << "maxTracesPerSecond=" << to_string(maxTracesPerSecond);
  out << ")";
}


OperationSamplingStrategy::~OperationSamplingStrategy() throw() {
}


void OperationSamplingStrategy::__set_operation(const std::string& val) {
  this->operation = val;
}

void OperationSamplingStrategy::__set_probabilisticSampling(const ProbabilisticSamplingStrategy& val) {
  this->probabilisticSampling = val;
}

uint32_t OperationSamplingStrategy::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_operation = false;
  bool isset_probabilisticSampling = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->operation);
          isset_operation = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->probabilisticSampling.read(iprot);
          isset_probabilisticSampling = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_operation)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_probabilisticSampling)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t OperationSamplingStrategy::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("OperationSamplingStrategy");

  xfer += oprot->writeFieldBegin("operation", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->operation);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("probabilisticSampling", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->probabilisticSampling.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(OperationSamplingStrategy &a, OperationSamplingStrategy &b) {
  using ::std::swap;
  swap(a.operation, b.operation);
  swap(a.probabilisticSampling, b.probabilisticSampling);
}

OperationSamplingStrategy::OperationSamplingStrategy(const OperationSamplingStrategy& other8) {
  operation = other8.operation;
  probabilisticSampling = other8.probabilisticSampling;
}
OperationSamplingStrategy::OperationSamplingStrategy( OperationSamplingStrategy&& other9) {
  operation = std::move(other9.operation);
  probabilisticSampling = std::move(other9.probabilisticSampling);
}
OperationSamplingStrategy& OperationSamplingStrategy::operator=(const OperationSamplingStrategy& other10) {
  operation = other10.operation;
  probabilisticSampling = other10.probabilisticSampling;
  return *this;
}
OperationSamplingStrategy& OperationSamplingStrategy::operator=(OperationSamplingStrategy&& other11) {
  operation = std::move(other11.operation);
  probabilisticSampling = std::move(other11.probabilisticSampling);
  return *this;
}
void OperationSamplingStrategy::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "OperationSamplingStrategy(";
  out << "operation=" << to_string(operation);
  out << ", " << "probabilisticSampling=" << to_string(probabilisticSampling);
  out << ")";
}


PerOperationSamplingStrategies::~PerOperationSamplingStrategies() throw() {
}


void PerOperationSamplingStrategies::__set_defaultSamplingProbability(const double val) {
  this->defaultSamplingProbability = val;
}

void PerOperationSamplingStrategies::__set_defaultLowerBoundTracesPerSecond(const double val) {
  this->defaultLowerBoundTracesPerSecond = val;
}

void PerOperationSamplingStrategies::__set_perOperationStrategies(const std::vector<OperationSamplingStrategy> & val) {
  this->perOperationStrategies = val;
}

void PerOperationSamplingStrategies::__set_defaultUpperBoundTracesPerSecond(const double val) {
  this->defaultUpperBoundTracesPerSecond = val;
__isset.defaultUpperBoundTracesPerSecond = true;
}

uint32_t PerOperationSamplingStrategies::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_defaultSamplingProbability = false;
  bool isset_defaultLowerBoundTracesPerSecond = false;
  bool isset_perOperationStrategies = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->defaultSamplingProbability);
          isset_defaultSamplingProbability = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->defaultLowerBoundTracesPerSecond);
          isset_defaultLowerBoundTracesPerSecond = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->perOperationStrategies.clear();
            uint32_t _size12;
            ::apache::thrift::protocol::TType _etype15;
            xfer += iprot->readListBegin(_etype15, _size12);
            this->perOperationStrategies.resize(_size12);
            uint32_t _i16;
            for (_i16 = 0; _i16 < _size12; ++_i16)
            {
              xfer += this->perOperationStrategies[_i16].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_perOperationStrategies = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->defaultUpperBoundTracesPerSecond);
          this->__isset.defaultUpperBoundTracesPerSecond = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_defaultSamplingProbability)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_defaultLowerBoundTracesPerSecond)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_perOperationStrategies)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t PerOperationSamplingStrategies::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("PerOperationSamplingStrategies");

  xfer += oprot->writeFieldBegin("defaultSamplingProbability", ::apache::thrift::protocol::T_DOUBLE, 1);
  xfer += oprot->writeDouble(this->defaultSamplingProbability);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("defaultLowerBoundTracesPerSecond", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble(this->defaultLowerBoundTracesPerSecond);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("perOperationStrategies", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->perOperationStrategies.size()));
    std::vector<OperationSamplingStrategy> ::const_iterator _iter17;
    for (_iter17 = this->perOperationStrategies.begin(); _iter17 != this->perOperationStrategies.end(); ++_iter17)
    {
      xfer += (*_iter17).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.defaultUpperBoundTracesPerSecond) {
    xfer += oprot->writeFieldBegin("defaultUpperBoundTracesPerSecond", ::apache::thrift::protocol::T_DOUBLE, 4);
    xfer += oprot->writeDouble(this->defaultUpperBoundTracesPerSecond);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PerOperationSamplingStrategies &a, PerOperationSamplingStrategies &b) {
  using ::std::swap;
  swap(a.defaultSamplingProbability, b.defaultSamplingProbability);
  swap(a.defaultLowerBoundTracesPerSecond, b.defaultLowerBoundTracesPerSecond);
  swap(a.perOperationStrategies, b.perOperationStrategies);
  swap(a.defaultUpperBoundTracesPerSecond, b.defaultUpperBoundTracesPerSecond);
  swap(a.__isset, b.__isset);
}

PerOperationSamplingStrategies::PerOperationSamplingStrategies(const PerOperationSamplingStrategies& other18) {
  defaultSamplingProbability = other18.defaultSamplingProbability;
  defaultLowerBoundTracesPerSecond = other18.defaultLowerBoundTracesPerSecond;
  perOperationStrategies = other18.perOperationStrategies;
  defaultUpperBoundTracesPerSecond = other18.defaultUpperBoundTracesPerSecond;
  __isset = other18.__isset;
}
PerOperationSamplingStrategies::PerOperationSamplingStrategies( PerOperationSamplingStrategies&& other19) {
  defaultSamplingProbability = std::move(other19.defaultSamplingProbability);
  defaultLowerBoundTracesPerSecond = std::move(other19.defaultLowerBoundTracesPerSecond);
  perOperationStrategies = std::move(other19.perOperationStrategies);
  defaultUpperBoundTracesPerSecond = std::move(other19.defaultUpperBoundTracesPerSecond);
  __isset = std::move(other19.__isset);
}
PerOperationSamplingStrategies& PerOperationSamplingStrategies::operator=(const PerOperationSamplingStrategies& other20) {
  defaultSamplingProbability = other20.defaultSamplingProbability;
  defaultLowerBoundTracesPerSecond = other20.defaultLowerBoundTracesPerSecond;
  perOperationStrategies = other20.perOperationStrategies;
  defaultUpperBoundTracesPerSecond = other20.defaultUpperBoundTracesPerSecond;
  __isset = other20.__isset;
  return *this;
}
PerOperationSamplingStrategies& PerOperationSamplingStrategies::operator=(PerOperationSamplingStrategies&& other21) {
  defaultSamplingProbability = std::move(other21.defaultSamplingProbability);
  defaultLowerBoundTracesPerSecond = std::move(other21.defaultLowerBoundTracesPerSecond);
  perOperationStrategies = std::move(other21.perOperationStrategies);
  defaultUpperBoundTracesPerSecond = std::move(other21.defaultUpperBoundTracesPerSecond);
  __isset = std::move(other21.__isset);
  return *this;
}
void PerOperationSamplingStrategies::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "PerOperationSamplingStrategies(";
  out << "defaultSamplingProbability=" << to_string(defaultSamplingProbability);
  out << ", " << "defaultLowerBoundTracesPerSecond=" << to_string(defaultLowerBoundTracesPerSecond);
  out << ", " << "perOperationStrategies=" << to_string(perOperationStrategies);
  out << ", " << "defaultUpperBoundTracesPerSecond="; (__isset.defaultUpperBoundTracesPerSecond ? (out << to_string(defaultUpperBoundTracesPerSecond)) : (out << "<null>"));
  out << ")";
}


SamplingStrategyResponse::~SamplingStrategyResponse() throw() {
}


void SamplingStrategyResponse::__set_strategyType(const SamplingStrategyType::type val) {
  this->strategyType = val;
}

void SamplingStrategyResponse::__set_probabilisticSampling(const ProbabilisticSamplingStrategy& val) {
  this->probabilisticSampling = val;
__isset.probabilisticSampling = true;
}

void SamplingStrategyResponse::__set_rateLimitingSampling(const RateLimitingSamplingStrategy& val) {
  this->rateLimitingSampling = val;
__isset.rateLimitingSampling = true;
}

void SamplingStrategyResponse::__set_operationSampling(const PerOperationSamplingStrategies& val) {
  this->operationSampling = val;
__isset.operationSampling = true;
}

uint32_t SamplingStrategyResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_strategyType = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast22;
          xfer += iprot->readI32(ecast22);
          this->strategyType = (SamplingStrategyType::type)ecast22;
          isset_strategyType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->probabilisticSampling.read(iprot);
          this->__isset.probabilisticSampling = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->rateLimitingSampling.read(iprot);
          this->__isset.rateLimitingSampling = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->operationSampling.read(iprot);
          this->__isset.operationSampling = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_strategyType)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t SamplingStrategyResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SamplingStrategyResponse");

  xfer += oprot->writeFieldBegin("strategyType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->strategyType);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.probabilisticSampling) {
    xfer += oprot->writeFieldBegin("probabilisticSampling", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->probabilisticSampling.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.rateLimitingSampling) {
    xfer += oprot->writeFieldBegin("rateLimitingSampling", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->rateLimitingSampling.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.operationSampling) {
    xfer += oprot->writeFieldBegin("operationSampling", ::apache::thrift::protocol::T_STRUCT, 4);
    xfer += this->operationSampling.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SamplingStrategyResponse &a, SamplingStrategyResponse &b) {
  using ::std::swap;
  swap(a.strategyType, b.strategyType);
  swap(a.probabilisticSampling, b.probabilisticSampling);
  swap(a.rateLimitingSampling, b.rateLimitingSampling);
  swap(a.operationSampling, b.operationSampling);
  swap(a.__isset, b.__isset);
}

SamplingStrategyResponse::SamplingStrategyResponse(const SamplingStrategyResponse& other23) {
  strategyType = other23.strategyType;
  probabilisticSampling = other23.probabilisticSampling;
  rateLimitingSampling = other23.rateLimitingSampling;
  operationSampling = other23.operationSampling;
  __isset = other23.__isset;
}
SamplingStrategyResponse::SamplingStrategyResponse( SamplingStrategyResponse&& other24) {
  strategyType = std::move(other24.strategyType);
  probabilisticSampling = std::move(other24.probabilisticSampling);
  rateLimitingSampling = std::move(other24.rateLimitingSampling);
  operationSampling = std::move(other24.operationSampling);
  __isset = std::move(other24.__isset);
}
SamplingStrategyResponse& SamplingStrategyResponse::operator=(const SamplingStrategyResponse& other25) {
  strategyType = other25.strategyType;
  probabilisticSampling = other25.probabilisticSampling;
  rateLimitingSampling = other25.rateLimitingSampling;
  operationSampling = other25.operationSampling;
  __isset = other25.__isset;
  return *this;
}
SamplingStrategyResponse& SamplingStrategyResponse::operator=(SamplingStrategyResponse&& other26) {
  strategyType = std::move(other26.strategyType);
  probabilisticSampling = std::move(other26.probabilisticSampling);
  rateLimitingSampling = std::move(other26.rateLimitingSampling);
  operationSampling = std::move(other26.operationSampling);
  __isset = std::move(other26.__isset);
  return *this;
}
void SamplingStrategyResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SamplingStrategyResponse(";
  out << "strategyType=" << to_string(strategyType);
  out << ", " << "probabilisticSampling="; (__isset.probabilisticSampling ? (out << to_string(probabilisticSampling)) : (out << "<null>"));
  out << ", " << "rateLimitingSampling="; (__isset.rateLimitingSampling ? (out << to_string(rateLimitingSampling)) : (out << "<null>"));
  out << ", " << "operationSampling="; (__isset.operationSampling ? (out << to_string(operationSampling)) : (out << "<null>"));
  out << ")";
}

}}}} // namespace
